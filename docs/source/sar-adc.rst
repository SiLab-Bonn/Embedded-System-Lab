========================================
Experiment: Successive Approximation ADC
========================================

.. figure:: images/sar_adc.png
    :width: 300
    :align: center

    SAR ADC Module

In this module, function and performance of a 8-bit successive-approximation register analog-digital-converter (SAR-ADC) will be studied. A SAR-ADC main function blocks consists of a digital-to-analog converter (DAC), a sampling switch and capacitor, a comparator and some digital control logic. The diagram below shows the basic function blocks. The SAR logic which will be implemented as part of the user code on the Raspberry Pi will control the DAC via an SPI bus and interface to the two GPIO signals SAMPLE and COMP_OUT. 

.. figure:: images/SAR_ADC_block.png
    :width: 600
    :align: center

    Functional block diagram of the SAR-ADC

Successive Approximation 
------------------------
A conversion begins with switching the input node from tracking the input voltage ("track mode") to storing its momentary value on the sampling capacitor ("hold mode"). In hold mode the input voltage to the comparator is kept constant during the conversion time of the SAR ADC. To find the binary representation of the stored voltage, its value is compared to the programmable output voltage of a digital-to-analog converter (DAC). In an iterative process the result of the comparison is used to define the next DAC output voltage. To minimize the number of necessary comparison cycles, the successive approximation method is used: Instead of linear increasing (or decreasing) the DAC output voltage and capturing the DAC register value at which the comparator output changes its state (this ADC type is called "Wilkinson" ADC), a SAR-ADC switches and compares the DAC voltage bit by bit starting from the most significant bit (MSB) down to the least significant bit (LSB). This method allows an n-Bit ADC to convert an analog value within n-cycles. The SAR sequence for a conversion which would be generated by the control logic looks like this (pseudo code):

.. code-block:: c

  1. // open the sample switch (hold mode)
  SAMPLE = 0

  2. // start with DAC mid-range voltage: set MSB to '1' by shifting a '1' n-bits to the left
  DAC_register = 1 << n          
  
  3. // Repeat code block below n-times while j runs from n-1 to 0.
  if (VDAC < VIN)            // compare ADC input with DAC output (i.e. read the result of the comparator)
    DAC_register -= (1 << j) // DAC output larger then VIN, subtract next LSB value from current DAC setting
  else
    DAC_register += (1 << j) // DAC output smaller then VIN, add next LSB value to current DAC setting
 
  4. // The final DAC register value after n-iterations is the digital representation of the analog input voltage.
  result = DAC_register

  5. // close the sample switch (track mode) to prepare the next conversion
  SAMPLE = 1
  
Digital to Analog Converter
---------------------------
The digital-to-analog converter is implemented with a resistive voltage divider and a reference voltage VREF. Programmable switches can set the output voltage in a range from 0 to VREF(2^(n-1))/(2^n) with a step size of VREF/(2^n). A resistive voltage divider for an n-bit DAC can be constructed from 2^n equal sized resistors and 2^n switches (also called a resistor string divider or thermometer encoded ladder) or a binary weighted ladder. The latter one would require only n+1 resistors with values from R to 2^n x R. However, the required matching of resistor values over that value range is typically not easy to achieve. A clever re-arrangement of resistor and switches using 2x n resistors and n switches allows the usage of resistors with the value R and 2x R only. This so-called R-2R ladder is used for the module's DAC.
 
 .. figure:: images/R2R_ladder.png
    :width: 600
    :align: center

    Resistive ladder (R-2R) digital analog converter
    
The voltage at the output of the ladder is VREF times the binary weighted sum of the DAC's register bits set to '1'.

.. math::
  
  V_{DAC} = V_{REF} \cdot \frac{DAC_{reg}}{2^n}}.


In the circuit implementation of thr R-2R DAC an 8-bit digital buffer which power supply is connected to VREF is used to switch the resistive ladder taps between 0 and VREF. 

 
Circuit Implementation 
----------------------
A simplified circuit diagram of the SAR-ADC is shown here
 
 .. figure:: images/SAR_ADC_circuit.png
    :width: 600
    :align: center

    Simplified circuit diagram

The full circuit schematic is found here: :download:`SAR_ADC_1.1.pdf <documents/SAR_ADC_1.1.pdf>`


ADC Characterisation
---------------------
An important performance parameter of an ADC is its linearity. An ideal n-bit ADC generates an binary output according to 

.. math::

  ADC_{code} = V_{IN} \cdot \frac{2^n}{V_{REF}}.


That implies that all ADC codes are representing the same bin width of analog values. Testing this specification can be done by generating analog voltages over the full ADC input range and comparing the conversion result to the generated voltage. Since the accuracy of the generated voltage has to be much higher then the resolution of the ADC, this procedure can be quite challenging, in particular for high resolution ADCs. A more efficient approach is to generate an input signal which is not precisely controlled step-by-step but rather provides a know amplitude density. This statistical method (also called histogram method) will be used for the ADC characterisation.


Test Signal Generator 
--------------------
The ADC module provides a simple signal generator which generates a saw-tooth waveform output voltage. This signal will be used to characterise the ADC's linearity.

- Dynamic rage, calibration
- Noise
- Linearity (INL/DNL)


Exercises 
---------
.. admonition:: Exercise 1. R-2R ladder 
  Show that the output voltage of a R-2R ladder is defined by 
  
.. admonition:: Exercise 2. SAR Logic

.. admonition:: Exercise 3. Dynamic range and calibration

.. admonition:: Exercise 4. Integrated- and Differential Nonlinearity

